1、调用存在的问题
	分布式SOA或者微服务，一套系统中存在多个微服务，服务调用服务无非就是使用RPC通信或者restful，既然是通信，那么就有可能在服务器处理完毕后返回结果的时候挂掉，这个时候用户端发现很久没有反应，就会多次点击，这样多次请求，那么处理数据的结果是否要统一呢？那么是肯定的，尤其是支付场景。

2、什么是接口幂等性
	就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条．．．,这就没有保证接口的幂等性
3、什么情况下需要保证接口的幂等性
	在增删改查4操作中，尤为注意是增加和修改。

C: 更新操作

	修改在大多场景下结果一样,但是如果是增量修改是需要保证幂等性的,如下例子:

	把表中id为XXX的记录的A字段值设置为1,这种操作不管执行多少次都是幂等的
	把表中id为XXX的记录的A字段值增加1,这种操作就不是幂等的

D: 新增操作

	增加在重复提交的场景下会出现幂等性问题,如以上的支付问题

4、那么如何设计接口才能做到幂等呢？
	常见的两种实现方案: 
	1、 通过代码逻辑判断实现 
	2、 使用token机制实现 下面以支付系统为例,分别对接口的幂等性进行说明与实现

A: 通过代码逻辑判断实现接口幂等性,只能针对一些满足判断的逻辑实现,具有一定局限性
B: 使用token机制实现接口幂等性,通用性强的实现方法

 token机制实现步骤:

 1. 生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token

 2. 提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,页面再次提交携带的token是已删除的token后台验证会失败不让提交


 token特点：   要申请，一次有效性，可以限流

 注意： redis要用删除操作来判断token，删除成功代表token校验通过，如果用select+delete来校验token，存在并发问题，不建议使用

 	3、悲观锁：获取数据的时候加锁获取
 	select * from table where id = '' for update;
 	悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。
	另外要注意的是，id字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。

	4、乐观锁：通过版本号或其他状态字段做更新限制。
	与悲观锁长时间锁表不一样，乐观锁只是在更新数据那一刻锁表，其他时间不锁表。所以乐观锁相对于悲观锁，在大部分场景中效率会更高一些。乐观锁的实现方式多种多样，可以通过version或者其他状态条件。
	比如给业务表内添加一个版本号的字段，如果要调用一个接口去更新年龄之前，就需要先查一下他的版本号是多少，然后调用接口的时候带上版本号。

	在接口里保证分布式接口的幂等性（在更新的SQL中添加version的条件判断）：

	update user set age = 21, version = version + 1 where id = 1 and version = 1;
	这样，多次提交的请求，因为版本号（version）都一样，因为第一次请求执行成功之后version已经+1了，则后面的请求因为version对应不上，都不会被执行。

	5、分布式锁：另一个角度的Token校验。

	如果是分布式系统的话，构建全局唯一索引会比较困难，比如唯一性的字段就没有办法确定。这时候可以引入分布式锁，通过第三方的系统（Redis或Zookeeper），在业务系统插入数据或者更新数据前，需要先获取分布式锁，然后才能做操作，操作完成之后就释放锁。这样其实是把单机系统里面多线程并发锁的思路引入了多个系统的场景，也就是分布式系统中的解决思路。

	要点：某个长流程处理过程要求不能并发执行，可以在流程执行之前根据某个标志（用户ID+后缀等）获取分布式锁，其他流程执行时获取锁就会失败，也就是同一时间该流程只能有一个能执行成功，执行完成后，释放分布式锁（分布式锁要第三方系统提供）。

	"他们就像星星一样那么亮，我永远都够不着。"

	你要去做一个大人，不要回头，不要难过。